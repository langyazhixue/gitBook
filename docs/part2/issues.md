收录了常见的前端问题和解决方案，本文档持续更新，欢迎大家补充。

下面是目前收录的问题：

* 数据处理问题
  * 变量被覆盖
  * 由map方法引起的bug
  * `JOSN.parse(`)和`JSON.stringify()`解析报错
  * 向下传递的属性名为关键字
  * 使用refs属性出错
  * 同步流程中存在异步函数（effects）
  * 脏数据提交
  * 其他数据返回不合符预期等
* 前端组件问题
  * 目录树的点击加载数据错误
  * 包管理问题
    * npm包某功能不生效
    * 版本冲突
    * 注意引入包时，配置包的版本
  * react问题
    * 滥用生命周期方法
    * setState()是异步的
    * 同一个接口调用两次
* 常见交互问题
  * 提交
  * 弹框
  * 编辑或需要信息回显的页面
  * 页面表单填写一半，误点击其他菜单
  * 目录树
  * 组件卸载
  * 函数防抖和函数节流
  * 列表为空
  * 按钮、图标、链接不可用状态
  * 按钮支持enter键盘事件
  * 明确错误反馈
  * 文本长度过长被截断
  * table选择行的热区
  * 弹框应该数据返回后关闭

#### 数据处理问题

##### 1. 变量被覆盖

描述：直接在一个作用域中使用`var`语句来声明一个变量，导致内部作用域的局部变量被覆盖；或者全局变量和某个函数的形参同名 .etc

解决方案：首先尽量避免使用`var`语句申明变量，尽量使用`let`或`const`。尽可能做到一个变量只在其作用域中有效。

##### 2. 由map方法引起的bug

1. 描述：数据非数组或者undefined引起的问题

​       解决方案：保证数据的可靠性，或者`(data || []).map`

2. 描述：控制台提示缺少什么key

   解决方案：遍历数组返回元素或者组件时需加上key属性作为唯一标识

##### 3. `JOSN.parse(`)和`JSON.stringify()`解析报错

描述：与预期数据结构不符合，可能是脏数据，一旦出错，整个页面渲染出错

解决方案：确保数据结构的正确性，无法保证时，`try catch`处理

##### 4. 向下传递的属性名为关键字

描述：父组件向子组件传属性，结果子组件获取不到

解决方案：属性名为关键字，比如key，这时候子组件肯定拿不到key属性

##### 5. 使用refs属性出错

1. 描述：使用`this.refs.a.b` 时，提示`a undefined`

   解决方案： 注意a组件的加载时机和`this.refs.a`调用时机，a只有在挂载到页面上后，this.refs.a才能获取到a的属性和方案，比如，在`componentWillMount()`中使用，必然获取不到，再比如，Modal未加载时，也获取不到对它的引用。因此，使用前，务必先判断是否存在。

2. 描述：使用`this.refs.a.b` 时，b不存在

   解决方案：若`this.refs.a`存在，而a中的b（可能是属性或者函数）却不存在，检查a组件时候使用了，`Form.create()`，在这种情况下，a中的state和函数是获取不到的，除了form的方法可以获取到。

不要过度使用ref，这是一种反模式，使用前，请思考是否有别的方法避免这种调用。

##### 6. 同步流程中存在异步函数（effects）

描述：在同步的代码块中混入异步代码，如发起一个异步请求，但是没有等到请求返回，就进入了同步的代码块，导致得到的结果永远是请求返回之前的。

解决方案：在异步请求的`callback()`中做接下来的逻辑或者使用`async`函数，让异步代块阻塞。

##### 7. 脏数据提交

描述：提交了不符合要求的数据

解决方案：做好form表单校验

##### 8. 其他数据返回不合符预期等

通用解决方案

* 对需要用到的数据做一个判断，最好有一个初始状态
* 写函数时，要保证数据的可靠性，尤其是数据结构，数据类型等方面，若不能保证，请做好类型判断、try catch处理等。



#### 前端组件问题

##### 1. 目录树的点击加载数据错误

- 描述：目录树的点击，第一次点击时获取该目录下的所有数据，第二次点击时获取所有数据
- 解决方案：目录树第一次点击获取焦点，第二次点击焦点消失。应使每次点击时都获取到焦点，当重复点击时，可以做防止多次调用接口的优化

##### 2. 包管理问题

* npm包某功能不生效

  描述：如echarts的某些用法，按照官网的配置在自己的项目却不生效

  实例：echarts功能失效

  解决方案： 请尝试在本地新建index.html引入npm包的源码，一般都会有xxx.js 或者xxx.min.js，再使用按是否生效，若生效，则代表项目其他包源码打包后和该包冲突，可尝试在index.html直接引入编译后的源码解决，注意，此时页面中使用到该包，不要import，直接用就可以了。若仍然无法解决该问题，在webpack文件中配置，去掉编译该包，再重启项目。

* 版本冲突

  描述：常见的比如，antd升版本后，与项目中的moment包有冲突

  解决方案：将moment编译后的源码在index.html中引入，在代码中直接使用。若仍然无法解决该问题，将antd和moment编译后的源码都在index.html中引入。解决流程同上，若仍无法解决，

* 注意引入包时，配置包的版本

  描述：引入包时，使用* 或者next等方式代替^x.x.x 或者具体版本，导致其他同学下载项目并安装时，安装的包版本较新，而不合符项目启动、编译出错，或者功能失效问题

  实例：conf项目react-hot-loader 包使用了next描述版本导致最新版本与项目配置代码冲突

  解决方案： 做好包版本管理，新增包时，明确版本，或^符号描述

##### 3. react问题

* 滥用生命周期方法

1. 描述：在`componentWillReceiveProps()`方法中`setState`，直接导致死循环，页面卡死，或请求发多次。

   解决方案：判断`nextProps`和`this.props`,来判断组件是否要进行更新或者使用pureRender HOC。

2. 描述：在`render`中使用`setState`，陷入死循环。

   解决方案：不要在render中使用setState，如果你死活要用，请做好条件判断。

* setState()是异步的

  描述：`this.setState()`会调用`render`方法，但并不会立即改变`state`的值

  解决方案：在`this.setState`中，第二个参数为回调函数，可在这里处理。或者，请直接使用你执行`this.setState`时，放入`state`的数据，而不是使用`this.state.xxx`。如：

  ```javascript
  1.
  this.setState({
    data:newData
  },()=>{
    console.log(this.state.data)  // 此时为newData
  })

  2.
  this.setState({
    data:newData
  })
  doSomthing(newData)   // 直接用newdata
  ```

* 同一个接口调用两次

  描述：可能是组件didMount了两次

  解决方案：找到组件什么情况下unMount了一次



#### 常见交互问题处理

##### 1. 提交

提交（新增、保存等）后按钮应禁用，在页面上同时覆盖遮罩层禁止其他动作，并做超时处理，如超过30s，右上角提示超时，并去掉遮罩

##### 2. 弹框

信息类、简短类弹框可点击遮罩层关闭； 多表单弹框建议关掉“点击遮罩层关闭”功能

##### 3. 编辑或需要信息回显的页面

在数据返回前，页面应为loading状态；表单页面，还应当禁止表单输入，防止这段时间内用户输入并提交数据，可根据情况添加页面遮罩和超时处理

##### 4. 页面表单填写一半，误点击其他菜单

此类页面，在页面跳转前，需要提示，是否取消数据填写，或用localStorage等方式缓存数据

##### 5. 目录树

开发时需要考虑目录树是否默认展开，没有特殊情况，可默认展开第一项

##### 6. 组件卸载

组件卸载之前，加在dom上的监听事件和定时器需要手动清除

##### 7. 函数防抖和函数节流

表单监听和onresize、onscroll事件可考虑函数防抖和函数节流

##### 8. 列表为空

列表（比如树）为空时，应有文字提醒

##### 9.按钮、图标、链接不可用状态

以tooltip+disabled+cursor的方式展示

##### 10. 按钮支持enter键盘事件

例如 确定、提交 等按钮，需思考是否需要enter键盘事件，若需要，则加上

##### 11. 明确错误

反馈给用户明确的错误

##### 12.文本长度过长被截断

若不能折行，则用...+tooltip的方式提示用户

##### 13.table选择行的热区

扩大表格选择的热区，非简单checkbox的选中区域，并提供某列的不在热区中的功能

##### 14.弹框应该数据返回后关闭

表单填写类弹框，提交后应该在后端返回结果之后再决定是否关闭，成功关闭，失败则不关闭，给用户提供二次编辑